//# P1827 [USACO3.4] 美国血统 American Heritage
//
//## 题目描述
//
//农夫约翰非常认真地对待他的奶牛们的血统。然而他不是一个真正优秀的记账员。他把他的奶牛们的家谱作成二叉树，并且把二叉树以更线性的“树的中序遍历”和“树的前序遍历”的符号加以记录而不是用图形的方法。
//
//你的任务是在被给予奶牛家谱的“树中序遍历”和“树前序遍历”的符号后，创建奶牛家谱的“树的后序遍历”的符号。每一头奶牛的姓名被译为一个唯一的字母。（你可能已经知道你可以在知道树的两种遍历以后可以经常地重建这棵树。）显然，这里的树不会有多于 $26$ 个的顶点。
//
//这是在样例输入和样例输出中的树的图形表达方式：
//
//
//```plain
//　　　　　　　　 C
//　　　　　　   /  \
//　　　　　　  /　　\
//　　　　　　 B　　  G
//　　　　　　/ \　　/
//　　　　   A   D  H
//　　　　　　  / \
//　　　　　　 E   F
//
//```
//
//附注：
//
//- 树的中序遍历是按照左子树，根，右子树的顺序访问节点；
//- 树的前序遍历是按照根，左子树，右子树的顺序访问节点；
//- 树的后序遍历是按照左子树，右子树，根的顺序访问节点。
//
//## 输入格式
//
//第一行一个字符串，表示该树的中序遍历。
//
//第二行一个字符串，表示该树的前序遍历。
//
//## 输出格式
//
//单独的一行表示该树的后序遍历。
//
//## 输入输出样例 #1
//
//### 输入 #1
//
//```
//ABEDFCHG
//CBADEFGH
//```
//
//### 输出 #1
//
//```
//AEFDBHGC
//```
//
//## 说明/提示
//
//题目翻译来自NOCOW。
//
//USACO Training Section 3.4# P1827 [USACO3.4] 美国血统 American Heritage
//
//## 题目描述
//
//农夫约翰非常认真地对待他的奶牛们的血统。然而他不是一个真正优秀的记账员。他把他的奶牛们的家谱作成二叉树，并且把二叉树以更线性的“树的中序遍历”和“树的前序遍历”的符号加以记录而不是用图形的方法。
//
//你的任务是在被给予奶牛家谱的“树中序遍历”和“树前序遍历”的符号后，创建奶牛家谱的“树的后序遍历”的符号。每一头奶牛的姓名被译为一个唯一的字母。（你可能已经知道你可以在知道树的两种遍历以后可以经常地重建这棵树。）显然，这里的树不会有多于 $26$ 个的顶点。
//
//这是在样例输入和样例输出中的树的图形表达方式：
//
//
//```plain
//　　　　　　　　 C
//　　　　　　   /  \
//　　　　　　  /　　\
//　　　　　　 B　　  G
//　　　　　　/ \　　/
//　　　　   A   D  H
//　　　　　　  / \
//　　　　　　 E   F
//
//```
//
//附注：
//
//- 树的中序遍历是按照左子树，根，右子树的顺序访问节点；
//- 树的前序遍历是按照根，左子树，右子树的顺序访问节点；
//- 树的后序遍历是按照左子树，右子树，根的顺序访问节点。
//
//## 输入格式
//
//第一行一个字符串，表示该树的中序遍历。
//
//第二行一个字符串，表示该树的前序遍历。
//
//## 输出格式
//
//单独的一行表示该树的后序遍历。
//
//## 输入输出样例 #1
//
//### 输入 #1
//
//```
//ABEDFCHG
//CBADEFGH
//```
//
//### 输出 #1
//
//```
//AEFDBHGC
//```
//
//## 说明/提示
//
//题目翻译来自NOCOW。
//
//USACO Training Section 3.4

#include <iostream>
#include <string>
using namespace std;

string a, b;

void dfs(int l1, int r1, int l2, int r2)
{
    //递归出口
    if(l1 > r1) return;

    //先处理左右子树
    //1.找根节点
    //2.划分左右子树
    int p = l1;
    while(a[p] != b[l2]) p++;

    dfs(l1, p - 1, l2 + 1, l2 + p - l1);//处理左子树
    dfs(p + 1, r1, l2 + p - l1 + 1, r2);//处理右子树

    cout << b[l2];
}

int main()
{
    cin >> a >> b;

    dfs(0, a.size() - 1, 0, b.size() - 1);

    return 0;
}
