//# P10457 占卜DIY
//
//## 题目描述
//
//lyd 学会了使用扑克 DIY 占卜。方法如下：一副去掉大小王的扑克共 $52$ 张，打乱后均分为 $13$ 堆，编号 $1\sim 13$，每堆 $4$ 张，其中第 $13$ 堆称作“生命牌”，也就是说你有 $4$ 条命。这里边，$4$ 张 $K$ 被称作死神。
//
//初始状态下，所有的牌背面朝上扣下。
//
//流程如下：
//
//- 抽取生命牌中的最上面一张（第一张）。
//- 把这张牌翻开，正面朝上，放到牌上的数字所对应编号的堆的最上边。（例如抽到 $2$，正面朝上放到第 $2$ 堆牌最上面，又比如抽到 $J$，放到第 $11$ 堆牌最上边，注意是正面朝上放）
//- 从刚放了牌的那一堆最底下（最后一张）抽取一张牌，重复第 $2$ 步。（例如你上次抽了 $2$，放到了第二堆顶部，现在抽第二堆最后一张发现是 $8$，又放到第 $8$ 堆顶部……）
//- 在抽牌过程中如果抽到 $K$，则称死了一条命，就扔掉 $K$ 再从第 $1$ 步开始。
//- 当发现四条命都死了以后，统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现 $4$ 张正面朝上的牌（比如 $4$ 个 $A$），则称“开了一对”，当然 $4$ 个 $K$ 是不算的。
//- 统计一共开了多少对，开了 $0$ 对称作“极凶”，$1\sim 2$ 对为“大凶”，$3$ 对为“凶”，$4\sim 5$ 对为“小凶”，$6$ 对为“中庸”，$7\sim 8$ 对“小吉”，$9$ 对为“吉”，$10\sim11$ 对为“大吉”，$12$ 对为“满堂开花，极吉”。
//
//如果还不明白，请参考样例。
//
//## 输入格式
//
//一共 $13$ 行，为每堆牌的具体牌是什么（不区分花色只区分数字），每堆输入的顺序为从上到下。
//
//为了便于读入，用 $0$ 代表 $10$。
//
//## 输出格式
//
//输出一共开了多少对。
//
//## 输入输出样例 #1
//
//### 输入 #1
//
//```
//8 5 A A
//K 5 3 2
//9 6 0 6
//3 4 3 4
//3 4 4 5
//5 6 7 6
//8 7 7 7
//9 9 8 8
//9 0 0 0
//K J J J
//Q A Q K
//J Q 2 2
//A K Q 2
//```
//
//### 输出 #1
//
//```
//9
//```
//
//## 说明/提示
//
//注解：第一条命死后前 $12$ 堆牌变成了这个样子：
//```
//A A A 8
//K 5 3 2
//3 9 6 0
//4 4 3 4
//5 5 3 4
//6 6 5 6
//7 7 7 7 
//8 8 8 9
//9 9 0 0
//0 K J J
//J Q A Q//抽到这里的K死掉了
//J Q 2 2
//```
//第二条命由于 $K$ 在生命牌中，所以直接死掉，不变。
//
//第三条命死后前 $12$ 堆牌变成了这个样子：
//```
//A A A A
//2 2 2 K
//3 3 3 3
//4 4 4 4
//5 5 5 5
//6 6 6 6
//7 7 7 7 
//8 8 8 8
//9 9 9 9
//0 0 0 0//抽到这里的K死掉了
//J J J Q
//Q Q J Q
//```
//第四条命死后前 $12$ 堆牌变成了这个样子：
//```
//A A A A
//2 2 2 2//抽到这里的K死掉了
//3 3 3 3
//4 4 4 4
//5 5 5 5
//6 6 6 6
//7 7 7 7 
//8 8 8 8
//9 9 9 9
//0 0 0 0
//J J J Q
//Q Q J Q
//```
//最后发现在所有已经正面朝上的牌中，$A\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 10$ 这 $9$ 对牌“开”了，（注意，第 $9$ 堆牌中的最后一张虽然也是 $9$，但是并没有被翻开！所以不能算）因此输出 $9$。

#include <iostream>
using namespace std;

const int N = 15, M = 6;

int n = 13, m = 4;
int a[N][M];
int cnt[N];  //记录每堆牌里面剩余拍张个数，方便拿到最后一张牌

void dfs(int x)
{
    //遇到13就停止
    if(x == 13) return;

    //拿到第x堆里面最后一张牌
    int t = a[x][cnt[x]];
    cnt[x]--;  //剩余牌数 - 1
    //继续处理拿到的牌
    dfs(t);
}

int main()
{
    //读入数据，将对应的字符转化成数字
    for(int i = 1; i <= n; i++)
    {
        cnt[i] = 4;
        for(int j = 1; j <= m; j++)
        {
            char ch;
            cin >> ch;
            if(ch >= '2' && ch <= '9') a[i][j] = ch - '0';
            else if(ch == 'A') a[i][j] = 1;
            else if(ch == '0') a[i][j] = 10;
            else if(ch == 'J') a[i][j] = 11;
            else if(ch == 'Q') a[i][j] = 12;
            else a[i][j] = 13;
        }
    }

    //从前往后依次处理每张牌
    for(int j = 1; j <= m; j++)
    {
        dfs(a[n][j]);
    }

    //统计结果
    int ret = 0;
    for(int i = 1; i <= n; i++)
    {
        if(cnt[i] == 0) ret++;
    }
    cout << ret << endl;

    return 0;
}
