//1205：汉诺塔问题
//
//时间限制: 1000 ms         内存限制: 65536 KB
//提交数:67365    通过数: 26686
//【题目描述】
//约19世纪末，在欧州的商店中出售一种智力玩具，在一块铜板上有三根杆，最左边的杆上自上而下、由小到大顺序串着由64个圆盘构成的塔。目的是将最左边杆上的盘全部移到中间的杆上，条件是一次只能移动一个盘，且不允许大盘放在小盘的上面。
//
//这是一个著名的问题，几乎所有的教材上都有这个问题。由于条件是一次只能移动一个盘，且不允许大盘放在小盘上面，所以64个盘的移动次数是：18,446,744,073,709,551,615
//
//这是一个天文数字，若每一微秒可能计算(并不输出)一次移动，那么也需要几乎一百万年。我们仅能找出问题的解决方法并解决较小N值时的汉诺塔，但很难用计算机解决64层的汉诺塔。
//
//假定圆盘从小到大编号为1, 2, ...
//
//【输入】
//输入为一个整数(小于20）后面跟三个单字符字符串。
//
//整数为盘子的数目，后三个字符表示三个杆子的编号。
//
//【输出】
//输出每一步移动盘子的记录。一次移动一行。
//
//每次移动的记录为例如 a->3->b 的形式，即把编号为3的盘子从a杆移至b杆。
//
//【输入样例】
//2 a b c
//【输出样例】
//a->1->c
//a->2->b
//c->1->b

#include <iostream>
using namespace std;

int n;
char a, b, c;

//将x个盘子从begin移动到end
//其中tmp是中转站
void move(int x, char begin, char tmp, char end)
{
	if(x == 0) return;
	
	move(x - 1, begin, end, tmp);
	printf("%c->%d->%c\n", begin, x, end);
	move(x - 1, tmp, begin, end);	
} 

int main()
{
	cin >> n >> a >> b >> c;
	move(n, a, c, b);  //把a上面n个盘子，借助c转移到b上 
	
	return 0;
}
