//# P1228 地毯填补问题
//
//## 题目描述
//
//相传在一个古老的阿拉伯国家里，有一座宫殿。宫殿里有个四四方方的格子迷宫，国王选择驸马的方法非常特殊，也非常简单：公主就站在其中一个方格子上，只要谁能用地毯将除公主站立的地方外的所有地方盖上，美丽漂亮聪慧的公主就是他的人了。公主这一个方格不能用地毯盖住，毯子的形状有所规定，只能有四种选择（如图）：
//
//![](https://cdn.luogu.com.cn/upload/image_hosting/cik5fiow.png)
//
//并且每一方格只能用一层地毯，迷宫的大小为 $2^k\times 2^k$ 的方形。当然，也不能让公主无限制的在那儿等，对吧？由于你使用的是计算机，所以实现时间为 $1$ 秒。
//
//## 输入格式
//
//输入文件共 $2$ 行。
//
//第一行一个整数 $k$，即给定被填补迷宫的大小为 $2^k\times 2^k$（$0\lt k\leq 10$）；
//第二行两个整数 $x,y$，即给出公主所在方格的坐标（$x$ 为行坐标，$y$ 为列坐标），$x$ 和 $y$ 之间有一个空格隔开。
//
//## 输出格式
//
//将迷宫填补完整的方案：每一补（行）为 $x\ y\ c$（$x,y$ 为毯子拐角的行坐标和列坐标，$c$ 为使用毯子的形状，具体见上面的图 $1$，毯子形状分别用 $1,2,3,4$ 表示，$x,y,c$ 之间用一个空格隔开）。
//
//## 输入输出样例 #1
//
//### 输入 #1
//
//```
//3                          
//3 3
//```
//
//### 输出 #1
//
//```
//5 5 1
//2 2 4
//1 1 4
//1 4 3
//4 1 2
//4 4 1
//2 7 3
//1 5 4
//1 8 3
//3 6 3
//4 8 1
//7 2 2
//5 1 4
//6 3 2
//8 1 2
//8 4 1
//7 7 1
//6 6 1
//5 8 3
//8 5 2
//8 8 1
//```
//
//## 说明/提示
//
//spj 报错代码解释：
//
//1. $c$ 越界；
//2. $x,y$ 越界；
//3. $(x,y)$ 位置已被覆盖；
//4. $(x,y)$ 位置从未被覆盖。
//
//$\text{upd 2023.8.19}$：增加样例解释。
//
//### 样例解释
//
//![](https://cdn.luogu.com.cn/upload/image_hosting/r9j8r452.png)

#include <iostream>

using namespace std;

void dfs(int a, int b, int x, int y, int k)
{
    if(k < 1) return;
    int len = 1 << (k - 1);

    if(x < a + len && y < b + len)  //障碍物在左上角
    {
        cout << a + len << " " << b + len << " 1" << endl;
        dfs(a, b, x, y, k - 1);
        dfs(a, b + len, a + len - 1, b + len, k - 1);
        dfs(a + len, b, a + len, b + len - 1, k - 1);
        dfs(a + len, b + len, a + len, b + len, k - 1);
    }
    else if(x >= a + len && y >= b + len)  //障碍物在右下角
    {
        cout << a + len - 1 << " " << b + len - 1 << " 4" << endl;
        dfs(a, b, a + len - 1, b + len - 1, k - 1);
        dfs(a, b + len, a + len - 1, b + len, k - 1);
        dfs(a + len, b, a + len, b + len - 1, k - 1);
        dfs(a + len, b + len, x, y, k - 1);
    }
    else if(x >= a + len)  //障碍物在左下角
    {
        cout << a + len - 1 << " " << b + len << " 3" << endl;
        dfs(a, b, a + len - 1, b + len - 1, k - 1);
        dfs(a, b + len, a + len - 1, b + len, k - 1);
        dfs(a + len, b, x, y, k - 1);
        dfs(a + len, b + len, a + len, b + len, k - 1);
    }
    else  //障碍物在右上角
    {
        cout << a + len << " " << b + len - 1<< " 2" << endl;
        dfs(a, b, a + len - 1, b + len - 1, k - 1);
        dfs(a, b + len, x, y, k - 1);
        dfs(a + len, b, a + len, b + len - 1, k - 1);
        dfs(a + len, b + len, a + len, b + len, k - 1);
    }
}

int main()
{
    int k, x, y;
    cin >> k >> x >> y;
    dfs(1, 1, x, y, k);

    return 0;
}
