//可乐和魔法封印
// 题解
// 
// 讨论
// 
// 查看他人的提交
// 
// 我的提交
//
//题号：NC235558
//时间限制：C/C++/Rust/Pascal 1秒，其他语言2秒
//空间限制：C/C++/Rust/Pascal 256 M，其他语言512 M
//64bit IO Format: %lld
//题目描述 
//牛可乐得到了一个长度为 
//n
//n 且非严格单调递增的序列 
//a
//a，然而这个序列被 
//q
//q 层魔法封印了，其中第 
//i
//i 层封印的问题包含两个整数 
//x
//i
//,
//y
//i
//(
//x
//i
//≤
//y
//i
//)
//x 
//i
//?
// ,y 
//i
//?
// (x 
//i
//?
// ≤y 
//i
//?
// )，牛可乐必须正确回答序列中大于等于 
//x
//i
//x 
//i
//?
// 且小于等于 
//y
//i
//y 
//i
//?
//  的数字个数才能够解开该层封印。
//
//牛可乐觉得这个问题太难了，于是他想请你帮助他解开序列的 
//q
//q 层封印。
//输入描述:
//第一行包含一个整数 
//n
//(
//1
//≤
//n
//≤
//1
//0
//5
//)
//n(1≤n≤10 
//5
// )，表示序列的长度。
//
//第二行包含 
//n
//n 个整数，其中 
//?
//1
//0
//9
//≤
//a
//i
//≤
//1
//0
//9
//?10 
//9
// ≤a 
//i
//?
// ≤10 
//9
// 。
//
//第三行包含一个整数 
//q
//(
//1
//≤
//q
//≤
//1
//0
//5
//)
//q(1≤q≤10 
//5
// )，代表封印层数。
//
//之后 
//q
//q 行，每行两个整数 
//x
//i
//,
//y
//i
//(
//?
//1
//0
//9
//≤
//x
//i
//≤
//y
//i
//≤
//1
//0
//9
//)
//x 
//i
//?
// ,y 
//i
//?
// (?10 
//9
// ≤x 
//i
//?
// ≤y 
//i
//?
// ≤10 
//9
// )，代表该层封印的询问。
//输出描述:
//对于每层封印，输出一行一个整数，代表在范围内的数字个数。
//示例1
//输入
//复制
//5
//1 2 3 4 5
//3
//2 6
//1 5
//3 3
//输出
//复制
//4
//5
//1
//说明
//对于第一层封印，
//2
//,
//3
//,
//4
//,
//5
//2,3,4,5在范围内，答案为 
//4
//4。
//
//对于第二层封印，
//1
//,
//2
//,
//3
//,
//4
//,
//5
//1,2,3,4,5在范围内，答案为 
//5
//5。
//
//对于第三层封印，
//3
//3在范围内，答案为 
//1
//1。
//示例2
//输入
//复制
//5
//1 1 2 3 3
//3
//1 1
//2 3
//1 3
//输出
//复制
//2
//3
//5


#include <iostream>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N];

int binary_search(int x, int y)
{
    //大于等于x的最小元素
    int left = 1, right = n;
    while(left < right)
    {
        int mid = (left + right) / 2;
        if(a[mid] >= x) right = mid;
        else left = mid + 1;
    }
    if(a[left] < x) return 0;
    int tmp = left;
    
    //小于等于y的最大元素
    left = 1, right = n;
    while(left < right)
    {
        int mid = (left + right + 1) / 2;
        if(a[mid] <= y) left = mid;
        else right = mid - 1;
    }
    
    if(a[left] > y) return 0;
    
    return left - tmp + 1;
}

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        cin >> a[i];
    }
    
    int Q;
    cin >> Q;
    while(Q--)
    {
        int x, y;
        cin >> x >> y;
        cout << binary_search(x, y) << endl;
    }
    
    return 0;
}
