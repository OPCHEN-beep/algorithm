//# P2327 [SCOI2005] 扫雷
//
//## 题目描述
//
//相信大家都玩过扫雷的游戏。那是在一个 $n\times m$ 的矩阵里面有一些雷，要你根据一些信息找出雷来。万圣节到了，“余”人国流行起了一种简单的扫雷游戏，这个游戏规则和扫雷一样，如果某个格子没有雷，那么它里面的数字表示和它 $8$ 连通的格子里面雷的数目。现在棋盘是 $n\times 2$ 的，第一列里面某些格子是雷，而第二列没有雷，如下图：
//
//![](https://cdn.luogu.com.cn/upload/pic/17825.png )
//
//由于第一列的雷可能有多种方案满足第二列的数的限制，你的任务即根据第二列的信息确定第一列雷有多少种摆放方案。
//
//## 输入格式
//
//第一行为 $N$，第二行有 $N$ 个数，依次为第二列的格子中的数。（$1\le N\le10000$）
//
//## 输出格式
//
//一个数，即第一列中雷的摆放方案数。
//
//## 输入输出样例 #1
//
//### 输入 #1
//
//```
//2
//1  1
//```
//
//### 输出 #1
//
//```
//2
//```

#include <iostream>

using namespace std;

const int N = 1e4 + 10;

int n;
int a[N], b[N];

//不放地雷
int check1()
{
    a[1] = 0;
    for(int i = 2; i <= n + 1; i++)
    {
        a[i] = b[i - 1] - a[i - 1] - a[i - 2];
        if(a[i] < 0 || a[i] > 1) return 0;
    }
    if(a[n + 1] == 0) return 1;
    else return 0;
}

//放地雷
int check2()
{
    a[1] = 1;
    for(int i = 2; i <= n + 1; i++)
    {
        a[i] = b[i - 1] - a[i - 1] - a[i - 2];
        if(a[i] < 0 || a[i] > 1) return 0;
    }
    if(a[n + 1] == 0) return 1;
    else return 0;
}

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> b[i];

    int ret = 0;
    ret += check1();
    ret += check2();

    cout << ret <<endl;

    return 0;
}
