//# P10449 费解的开关
//
//## 题目描述
//
//你玩过“拉灯”游戏吗？
//
//$25$ 盏灯排成一个 $5 \times 5$ 的方形。
//
//每一个灯都有一个开关，游戏者可以改变它的状态。
//
//每一步，游戏者可以改变某一个灯的状态。
//
//游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。
//
//我们用数字 $1$ 表示一盏开着的灯，用数字 $0$ 表示关着的灯。
//
//下面这种状态
//
//    10111
//    01101
//    10111
//    10000
//    11011
//
//
//在改变了最左上角的灯的状态后将变成：
//
//    01111
//    11101
//    10111
//    10000
//    11011
//
//
//再改变它正中间的灯后状态将变成：
//
//    01111
//    11001
//    11001
//    10100
//    11011
//
//
//给定一些游戏的初始状态，编写程序判断游戏者是否可能在 $6$ 步以内使所有的灯都变亮。
//
//## 输入格式
//
//第一行输入正整数 $n$，代表数据中共有 $n$ 个待解决的游戏初始状态。
//
//以下若干行数据分为 $n$ 组，每组数据有 $5$ 行，每行 $5$ 个字符。
//
//每组数据描述了一个游戏的初始状态。
//
//各组数据间用一个空行分隔。
//
//## 输出格式
//
//一共输出 $n$ 行数据，每行有一个小于等于 $6$ 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。
//
//对于某一个游戏初始状态，若 $6$ 步以内无法使所有灯变亮，则输出 `-1`。
//
//## 输入输出样例 #1
//
//### 输入 #1
//
//```
//3
//00111
//01011
//10001
//11010
//11100
//
//11101
//11101
//11110
//11111
//11111
//
//01111
//11111
//11111
//11111
//11111
//```
//
//### 输出 #1
//
//```
//3
//2
//-1
//```
//
//## 说明/提示
//
//测试数据满足 $0 < n \le 500$。

#include <iostream>
#include <cstring> 
using namespace std;

const int N = 10;

int n = 5;
int a[N];//用二进制来储存灯的状态
int t[N];//备份a数组

int calc(int x)
{
    int cnt = 0;
    while(x)
    {
        cnt++;
        x &= x - 1;
    }
    return cnt;
}

int main()
{
    int T;
    cin >> T;

    while(T--)
    {
        //多组测试时清空之前的数据
        memset(a, 0, sizeof a);

        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n ; j++)
            {
                char ch;
                cin >> ch;
                //存成相反的
                if(ch == '0') a[i] |= 1 << j;
            }
        }

        int ret = 0x3f3f3f3f;//统计所有合法按法中的最小值
        //枚举第一行所有的按法
        for(int st = 0; st < (1 << n); st++)
        {
            memcpy(t, a, sizeof a);
            int push = st;//当前行的按法
            int cnt = 0;//统计当前按法下一共按了多少次

            //依次计算后续行的结果以及按法
            for(int i = 0; i < n; i++)
            {
                cnt += calc(push);
                //修改当前行被按的结果
                t[i] = t[i] ^ push ^ (push << 1) ^ (push >> 1);
                t[i] &= (1 << n) - 1;//清空影响
                //修改下一行的状态
                t[i + 1] ^= push;
                //下一行的按法
                push = t[i];
            }
            if(t[n - 1] == 0) ret = min(ret, cnt);
        }

        if(ret > 6) cout << -1 << endl;
        else cout << ret << endl; 
    }

    return 0;
}
