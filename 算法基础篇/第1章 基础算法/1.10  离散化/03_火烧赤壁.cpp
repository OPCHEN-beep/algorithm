//# P1496 火烧赤壁
//
//## 题目背景
//
//曹操平定北方以后，公元 208 年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。
//
//孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。
//
//隆冬的十一月，天气突然回暖，刮起了东南风。
//
//没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。
//
//曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！
//
//## 题目描述
//
//给定每个起火部分的起点和终点，请你求出燃烧位置的长度之和。
//
//## 输入格式
//
//第一行一个整数，表示起火的信息条数 $n$。  
//接下来 $n$ 行，每行两个整数 $a, b$，表示一个着火位置的起点和终点（**注意：左闭右开**）。
//
//## 输出格式
//
//输出一行一个整数表示答案。
//
//## 输入输出样例 #1
//
//### 输入 #1
//
//```
//3
//-1 1
//5 11
//2 9
//```
//
//### 输出 #1
//
//```
//11
//```
//
//## 说明/提示
//
//### 数据规模与约定
//
//对于全部的测试点，保证 $1 \leq n \leq 2 \times 10^4$，$-2^{31} \leq a <  b \lt 2^{31}$，且答案小于 $2^{31}$。

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 2e4 + 10;

int n;
int l[N], r[N];

int m;  //离散数组的大小
int disc[N * 2];  //离散之后的数组
int f[N * 2];     //差分数组

int find(int x)
{
    int l = 1, r = m;
    while(l < r)
    {
        int mid = (l + r + 1) >> 1;
        if(disc[mid] <= x) l = mid;
        else r = mid - 1;
    }
    return l;
}

int main()
{
    cin >> n;
    for(int i = 1; i <= n; i++)
    {
        int x, y;
        cin >> x >> y;
        l[i] = x, r[i] = y;
        disc[++m] = l[i], disc[++m] = r[i];
    }

    //离散化处理
    sort(disc + 1, disc + 1 + m);
    m = unique(disc + 1, disc + 1 + m) - disc - 1;

    //处理区间修改
    for(int i = 1; i <= n; i++)
    {
        int x = find(l[i]), y = find(r[i]);
        f[x] += 1, f[y] -= 1;
    }

    //还原数组
    for(int i = 1; i <= m; i++) f[i] += f[i - 1];

    //找出每一段大于0的区间，统计长度
    int sum = 0;
    for(int i = 1; i <= m; i++)
    {
        if(f[i] <= 0) continue;
        int j = i;
        while(j <= m && f[j] > 0) j++;
        //累加长度的时候使用离散化之前的值
        sum += disc[j] - disc[i];
        i = j;
    }
    cout << sum << endl;
    
    return 0;
}
