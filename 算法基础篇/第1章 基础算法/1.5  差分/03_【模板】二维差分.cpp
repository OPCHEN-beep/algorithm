//【模板】二维差分
// 题解
// 
// 讨论
// 
// 查看他人的提交
// 
// 我的提交
//
//题号：NC226337
//时间限制：C/C++/Rust/Pascal 2秒，其他语言4秒
//空间限制：C/C++/Rust/Pascal 256 M，其他语言512 M
//64bit IO Format: %lld
//题目描述 
//给定一个 
//n
//×
//m
//n×m 的整数矩阵 
//b
//b，矩阵的下标从 
//1
//1 开始记作 
//b
//i
//,
//j
//b 
//i,j
//?
// 。现在需要支持 
//q
//q 次操作，第 
//t
//t 次操作给定五个整数 
//x
//1
//,
//y
//1
//,
//x
//2
//,
//y
//2
//,
//k
//x 
//1
//?
// ,y 
//1
//?
// ,x 
//2
//?
// ,y 
//2
//?
// ,k，表示将以左上角 
//(
//x
//1
//,
//y
//1
//)
//(x 
//1
//?
// ,y 
//1
//?
// )、右下角 
//(
//x
//2
//,
//y
//2
//)
//(x 
//2
//?
// ,y 
//2
//?
// ) 为边界的子矩阵内的每个元素都增加 
//k
//k。全部操作执行完毕后，请输出最终矩阵。
//
//【名词解释】
//?
//?
//?子矩阵：从矩阵中连续选取若干行与若干列得到的矩形区域。
//输入描述:
//在一行上输入三个整数 
//n
//,
//m
//,
//q
//(
//1
//Q
//n
//,
//m
//Q
//1000
//;
// 
//1
//Q
//q
//Q
//1
//0
//5
//)
//n,m,q(1Qn,mQ1000; 1QqQ10 
//5
// )，依次表示矩阵行数、列数与操作次数。 
//此后 
//n
//n 行，第 
//i
//i 行输入 
//m
//m 个整数 
//b
//i
//,
//1
//,
//b
//i
//,
//2
//,
//…
//,
//b
//i
//,
//m
//(
//?
//1
//0
//9
//Q
//b
//i
//,
//j
//Q
//1
//0
//9
//)
//b 
//i,1
//?
// ,b 
//i,2
//?
// ,…,b 
//i,m
//?
// (?10 
//9
// Qb 
//i,j
//?
// Q10 
//9
// )，描述矩阵初始元素。 
//再之后 
//q
//q 行，每行输入五个整数 
//x
//1
//,
//y
//1
//,
//x
//2
//,
//y
//2
//,
//k
//(
//1
//Q
//x
//1
//Q
//x
//2
//Q
//n
//;
// 
//1
//Q
//y
//1
//Q
//y
//2
//Q
//m
//;
// 
//?
//1
//0
//9
//Q
//k
//Q
//1
//0
//9
//)
//x 
//1
//?
// ,y 
//1
//?
// ,x 
//2
//?
// ,y 
//2
//?
// ,k(1Qx 
//1
//?
// Qx 
//2
//?
// Qn; 1Qy 
//1
//?
// Qy 
//2
//?
// Qm; ?10 
//9
// QkQ10 
//9
// )，描述一次矩阵加法操作。
//输出描述:
//输出 
//n
//n 行，每行 
//m
//m 个整数，表示所有操作结束后矩阵的最终状态。同行相邻元素之间使用一个空格分隔。
//示例1
//输入
//复制
//2 3 4
//1 2 3
//4 5 6
//1 1 2 2 3
//1 2 2 3 -1
//1 1 1 3 4
//1 1 2 1 1
//输出
//复制
//9 8 6
//8 7 5
//说明
//在该样例中： 
//?
//?
//?第一次操作将 
//(
//1
//,
//1
//)
//?
//(
//2
//,
//2
//)
//(1,1)?(2,2) 内的四个元素各自增加 
//3
//3； 
//?
//?
//?第二次操作将 
//(
//1
//,
//2
//)
//?
//(
//2
//,
//3
//)
//(1,2)?(2,3) 内的六个元素各自减少 
//1
//1； 
//?
//?
//?第三次操作将 
//(
//1
//,
//1
//)
//?
//(
//1
//,
//3
//)
//(1,1)?(1,3) 内的三个元素各自增加 
//4
//4； 
//?
//?
//?第四次操作将 
//(
//1
//,
//1
//)
//?
//(
//2
//,
//1
//)
//(1,1)?(2,1) 内的两个元素各自增加 
//1
//1。 
//最终得到的矩阵如输出所示。
//示例2
//输入
//复制
//3 3 1
//0 0 0
//0 0 0
//0 0 0
//1 1 3 3 5
//输出
//复制
//5 5 5
//5 5 5
//5 5 5
//说明
//该样例中只进行一次操作，将整个矩阵所有元素都增加 
//5
//5。

#include <iostream>
using namespace std;

typedef long long LL;

const int N = 1010;

int n, m, q;
LL f[N][N];//差分矩阵

//差分矩阵的性质
void insert(int x1, int y1, int x2, int y2, LL k)
{
    f[x1][y1] += k; 
    f[x1][y2 + 1] -= k;
    f[x2 + 1][y1] -= k;
    f[x2 + 1][y2 + 1] += k;
}

int main()
{
    cin >> n >> m >> q;
    //预处理差分矩阵
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m ; j++)
        {
            LL x;
            cin >> x;
            insert(i, j, i, j, x);
        }
    }
    
    //处理q次修改操作
    while(q--)
    {
        LL x1, y1, x2, y2, k;
        cin >> x1 >> y1 >> x2 >> y2 >> k;
        insert(x1, y1, x2, y2, k);
    }
    
    //利用前缀和还原出修改之后的数组
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + f[i][j];
            cout << f[i][j] << " ";
        }
        
        cout << endl;
    }
    
    return 0;
}
