//# P3397 地毯
//
//## 题目背景
//
//[加强版](/problem/P13787)
//
//## 题目描述
//
//在 $n\times n$ 的格子上有 $m$ 个地毯。
//
//给出这些地毯的信息，问每个点被多少个地毯覆盖。
//
//## 输入格式
//
//第一行，两个正整数 $n,m$。意义如题所述。
//
//接下来 $m$ 行，每行两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。
//
//## 输出格式
//
//输出 $n$ 行，每行 $n$ 个正整数。
//
//第 $i$ 行第 $j$ 列的正整数表示 $(i,j)$ 这个格子被多少个地毯覆盖。
//
//## 输入输出样例 #1
//
//### 输入 #1
//
//```
//5 3
//2 2 3 3
//3 3 5 5
//1 2 1 4
//```
//
//### 输出 #1
//
//```
//0 1 1 1 0
//0 1 1 0 0
//0 1 2 1 1
//0 0 1 1 1
//0 0 1 1 1
//```
//
//## 说明/提示
//
//### 样例解释
//
//覆盖第一个地毯后：
//
//|$0$|$0$|$0$|$0$|$0$|
//|:-:|:-:|:-:|:-:|:-:|
//|$0$|$1$|$1$|$0$|$0$|
//|$0$|$1$|$1$|$0$|$0$|
//|$0$|$0$|$0$|$0$|$0$|
//|$0$|$0$|$0$|$0$|$0$|
//
//覆盖第一、二个地毯后：
//
//|$0$|$0$|$0$|$0$|$0$|
//|:-:|:-:|:-:|:-:|:-:|
//|$0$|$1$|$1$|$0$|$0$|
//|$0$|$1$|$2$|$1$|$1$|
//|$0$|$0$|$1$|$1$|$1$|
//|$0$|$0$|$1$|$1$|$1$|
//
//覆盖所有地毯后：
//
//|$0$|$1$|$1$|$1$|$0$|
//|:-:|:-:|:-:|:-:|:-:|
//|$0$|$1$|$1$|$0$|$0$|
//|$0$|$1$|$2$|$1$|$1$|
//|$0$|$0$|$1$|$1$|$1$|
//|$0$|$0$|$1$|$1$|$1$|
//
//---
//
//### 数据范围
//
//对于 $20\%$ 的数据，有 $n\le 50$，$m\le 100$。
//
//对于 $100\%$ 的数据，有 $n,m\le 1000$。

#include <iostream>
using namespace std;

const int N = 1010;

int n, m;
int f[N][N];//差分矩阵

//差分数组的性质
void insert(int x1, int y1, int x2, int y2, int k)
{
    f[x1][y1] += k;
    f[x1][y2 + 1] -= k;
    f[x2 + 1][y1] -= k;
    f[x2 + 1][y2 + 1] += k;
}

int main()
{
    cin >> n >> m;

    //构建差分数组
    while(m--)
    {
        int x1, x2, y1, y2;
        cin >> x1 >>y1 >> x2 >> y2;
        insert(x1, y1, x2, y2, 1);
    }

    //利用前缀和还原修改之后的数组
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= n; j++)
        {
            f[i][j] = f[i - 1][j] + f[i][j - 1] - f[i - 1][j - 1] + f[i][j];
            cout << f[i][j] << " ";
        }

        cout << endl;
    }

    return 0;
}
