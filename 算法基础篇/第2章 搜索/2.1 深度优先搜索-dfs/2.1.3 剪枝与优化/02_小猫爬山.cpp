//# P10483 小猫爬山
//
//## 题目描述
//
//Freda 和 rainbow 饲养了 $N(N\le 18)$ 只小猫，这天，小猫们要去爬山。经历了千辛万苦，小猫们终于爬上了山顶，但是疲倦的它们再也不想徒步走下山了
//
//Freda 和 rainbow 只好花钱让它们坐索道下山。索道上的缆车最大承重量为 $W$，而 $N$ 只小猫的重量分别是 $C_1,C_2,\dots C_N$。当然，每辆缆车上的小猫的重量之和不能超过 $W(1\le C_i,W \le 10^8)$。每租用一辆缆车，Freda 和 rainbow 就要付 $1$ 美元，所以他们想知道，最少需要付多少美元才能把这 $N$ 只小猫都运送下山？
//
//## 输入格式
//
//第一行包含两个用空格隔开的整数，$N$ 和 $W$。
//接下来 $N$ 行每行一个整数，其中第 $i+1$ 行的整数表示第 $i$ 只小猫的重量 $C_i$。
//
//## 输出格式
//
//输出一个整数，最少需要多少美元，也就是最少需要多少辆缆车。
//
//## 输入输出样例 #1
//
//### 输入 #1
//
//```
//5 1996
//1
//2
//1994
//12
//29
//```
//
//### 输出 #1
//
//```
//2
//```

#include <iostream>
#include <algorithm>

using namespace std;

const int N = 20;

int n, w;
int c[N];  //小猫的信息

int cnt;   //当前用了多少车
int s[N];  //每一辆车目前的总重

int ret = N;  //最优解

bool cmp(int a, int b)
{
    return a > b;
}

void dfs(int pos)
{
    //最优性剪枝
    if(cnt >= ret) return;

    if(pos > n)
    {
        ret = cnt;
        return;
    }

    //优化搜索顺序
    //先安排在已有的车上
    for(int i = 1; i <= cnt; i++)
    {
        //可行性剪枝
        if(s[i] + c[pos] > w) continue;
        s[i] += c[pos];
        dfs(pos + 1);
        s[i] -= c[pos];//恢复现场
    }

    //重开一辆车
    cnt++;
    s[cnt] = c[pos];
    dfs(pos + 1);
    //恢复现场
    s[cnt] = 0;
    cnt--;
}

int main()
{
    cin >> n >> w;
    for(int i = 1; i <= n; i++) cin >> c[i];

    //优化搜索顺序
    sort(c + 1, c + 1 + n, cmp);

    dfs(1);

    cout << ret << endl;

    return 0;
}
