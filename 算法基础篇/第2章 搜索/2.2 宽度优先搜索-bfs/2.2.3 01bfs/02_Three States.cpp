//# CF590C Three States
//
//## 题目描述
//
//著名的全球经济危机正在迅速逼近，因此伯曼、伯兰斯和伯塔利三个州组建了一个联盟，并允许所有成员国的居民自由通过任意一个成员国的领土。此外，决定在各州之间修建道路，以保证可以从任何一个国家的任意地点到达其他国家的任意地点。
//
//由于修路总是昂贵的，新成立联盟的各国政府请你帮忙评估成本。为此，你被发放了一张地图，地图可以表示为一个包含 $n$ 行 $m$ 列的矩形表格。地图上的每个格子要么属于三个州中的某一个州，要么是允许修建道路的区域（用 "." 表示），要么是禁止修建道路的区域（用 "#" 表示）。如果一个格子属于某个州，或者在该格子上修建了道路，则称该格子为“可通行”的。你可以从任意一个可通行格子向上、下、左、右移动一格，如果移动到的格子存在且可通行。
//
//你的任务是在尽量少的格子内修建道路，使得能够通过仅经过可通行格子，从任何一个国家的任意格子到达其他国家的任意格子。
//
//保证初始时，每个国家内部的任意两个格子可以互相到达（仅通过本国格子的移动）。保证每个国家至少有一个格子属于它。
//
//## 输入格式
//
//输入的第一行包含地图的尺寸 $n$ 和 $m$（$1 \leq n, m \leq 1000$），分别表示行数和列数。
//
//接下来的 $n$ 行每行包含 $m$ 个字符，描述地图的各行。字符 $1$ 到 $3$ 表示该格子属于相应的国家。字符 "." 表示该格子允许修路，字符 "#" 表示该格子禁止修路。
//
//## 输出格式
//
//输出一个整数，表示需要修路的最小格子数，使得所有国家的所有格子互相连通。如果无法实现，输出 $-1$。
//
//## 输入输出样例 #1
//
//### 输入 #1
//
//```
//4 5
//11..2
//#..22
//#.323
//.#333
//```
//
//### 输出 #1
//
//```
//2
//```
//
//## 输入输出样例 #2
//
//### 输入 #2
//
//```
//1 5
//1#2#3
//```
//
//### 输出 #2
//
//```
//-1
//```
//
//## 说明/提示
//
//由 ChatGPT 5 翻译

#include <iostream>
#include <deque>
#include <cstring>

using namespace std;

const int N = 1e3 + 10;

int n, m;
char g[N][N];
int dist[4][N][N];

int dx[4] = {0, 0, 1, -1};
int dy[4] = {1, -1, 0, 0};

void bfs(int num)
{
    memset(dist[num], -1, sizeof dist[num]);

    //将所有源点加入到队列中
    deque<pair<int, int>> q;
    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            if(g[i][j] - '0' == num)
            {
                q.push_back({i, j});
                dist[num][i][j] = 0;
            }
        }
    }

    while(q.size())
    {
        auto [a, b] = q.front(); q.pop_front();

        for(int i = 0; i < 4; i++)
        {
            int x = a + dx[i], y = b + dy[i];

            if(x > 1 && x <= n && y > 1 && y <= m)
            {
                if(g[x][y] == '#' || dist[num][x][y] != -1) continue;

                if(g[x][y] == '.') //边权是1
                {
                    dist[num][x][y] = dist[num][a][b] + 1;
                    q.push_back({x, y});  //放队尾
                }
                else  //边权是0
                {
                    dist[num][x][y] = dist[num][a][b];
                    q.push_back({x, y});  //放队头
                }
            }
        }
    }
}

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cin >> g[i][j];

    //更新三个国家距离其余点的最短距离
    bfs(1);
    bfs(2);
    bfs(3);

    int ret = 1e6 + 10;

    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
        {
            int a = dist[1][i][j], b = dist[2][i][j], c = dist[3][i][j];
            if(a == -1 || b == -1 || c == -1)
            {
                continue;
            }


            //更新结果
            if(g[i][j] == '.') ret = min(ret, a + b + c - 2);
            else ret = min(ret, a + b + c);
        }

    if(ret == 1e6 + 10) cout << -1 << endl;
    else cout << ret << endl;

    return 0;
}
