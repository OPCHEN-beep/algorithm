//【模板】01背包
// 题解
// 
// 讨论
// 
// 查看他人的提交
// 
// 我的提交
//
//题号：NC226514
//时间限制：C/C++/Rust/Pascal 1秒，其他语言2秒
//空间限制：C/C++/Rust/Pascal 256 M，其他语言512 M
//64bit IO Format: %lld
//题目描述 
//你有一个背包，最大容量为 
//V
//V。现有 
//n
//n 件物品，第 
//i
//i 件物品的体积为 
//v
//i
//v 
//i
//?
// ，价值为 
//w
//i
//w 
//i
//?
// 。研究人员提出以下两种装填方案：
//1.
//?
//1.
//?
//  不要求装满背包，求能获得的最大总价值；
//2.
//?
//2.
//?
//  要求最终恰好装满背包，求能获得的最大总价值。若不存在使背包恰好装满的装法，则答案记为 
//0
//0。
//输入描述:
//第一行输入两个整数 
//n
//n 和 
//V
//(
//1
//Q
//n
//,
//V
//Q
//1
//0
//3
//)
//V(1Qn,VQ10 
//3
// )，分别表示物品数量与背包容量。 
//此后 
//n
//n 行，第 
//i
//i 行输入两个整数 
//v
//i
//,
//w
//i
//(
//1
//Q
//v
//i
//,
//w
//i
//Q
//1
//0
//3
//)
//v 
//i
//?
// ,w 
//i
//?
// (1Qv 
//i
//?
// ,w 
//i
//?
// Q10 
//3
// )，分别表示第 
//i
//i 件物品的体积与价值。
//输出描述:
//输出两行： 
//1.
//?
//1.
//?
//  第一行输出方案 
//1
//1 的答案； 
//2.
//?
//2.
//?
//  第二行输出方案 
//2
//2 的答案（若无解输出 
//0
//0）。
//示例1
//输入
//复制
//3 5
//2 10
//4 5
//1 4
//输出
//复制
//14
//9
//说明
//在该组样例中： 
//?
//?
//? 选择第 
//1
//1、第 
//3
//3 件物品即可获得最大价值 
//10
//+
//4
//=
//14
//10+4=14（未装满）； 
//?
//?
//? 选择第 
//2
//2、第 
//3
//3 件物品可使背包体积 
//4
//+
//1
//=
//5
//4+1=5 恰好装满且价值最大，为 
//5
//+
//4
//=
//9
//5+4=9。
//示例2
//输入
//复制
//3 8
//12 6
//11 8
//6 8
//输出
//复制
//8
//0
//说明
//装第三个物品时总价值最大但是不满，装满背包无解。
//备注:
//要求 
//O
//(
//n
//V
//)
//O(nV) 的时间复杂度，
//O
//(
//V
//)
//O(V) 空间复杂度。

#include <iostream>
#include <cstring>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> v[i] >> w[i];
    
    //第一问
    for(int i = 1; i<= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            f[i][j] = f[i - 1][j];
            if(j >= v[i])
            {
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
            }
        }   
    }
    
    cout << f[n][m] << endl;
    
    //第二问
    memset(f, -0x3f, sizeof f);
    f[0][0] = 0;
    for(int i = 1; i <= n; i++)
    {
        for(int j = 0; j <= m; j++)
        {
            f[i][j] = f[i - 1][j];
            if(j >= v[i])
            {
                f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
            }
        }
    }
    
    if(f[n][m] < 0) cout << 0 << endl;
    else cout << f[n][m] << endl;
    
    return 0;
}
