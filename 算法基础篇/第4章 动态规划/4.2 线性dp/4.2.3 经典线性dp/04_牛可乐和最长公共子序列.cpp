//牛可乐和最长公共子序列
// 题解
// 
// 讨论
// 
// 查看他人的提交
// 
// 我的提交
//
//题号：NC235624
//时间限制：C/C++/Rust/Pascal 1秒，其他语言2秒
//空间限制：C/C++/Rust/Pascal 256 M，其他语言512 M
//64bit IO Format: %lld
//题目描述 
//牛可乐得到了两个字符串 
//s
//s 和 
//t
//t ,牛可乐想请聪明的你帮他计算出来，两个字符串的最长公共子序列长度是多少。
//
//最长公共子序列的定义是，子序列中的每个字符都能在两个原串中找到，而且每个字符的先后顺序和原串中的先后顺序一致。
//输入描述:
//输入包含多组数据，请读至文件末尾。
//每行包含两个字符串 
//s
//,
//t
//s,t，两个字符串用一个空格字符间隔，单个字符串长度不超过 
//5000
//5000。
//
//数据保证所有数据的字符串 
//s
//s 长度之和与字符串 
//t
//t 长度之和均不超过 
//5000
//5000。
//输出描述:
//对于每组数据，输出一个整数，代表最长公共子序列的长度。
//示例1
//输入
//复制
//abccde bcee
//输出
//复制
//3
//说明
//最长公共子序列长度为 
//b
//c
//e
//bce，长度为 
//3
//3。

#include <iostream>

using namespace std;

const int N = 5010;

string s, t;
int f[N][N];

int main()
{
    while(cin >> s >> t)
    {
        int n = s.size(), m = t.size();
        
        for(int i = 1; i <= n; i++)
        {
            for(int j = 1; j <= m; j++)
            {
                if(s[i - 1] == t[j - 1]) f[i][j] = f[i - 1][j - 1] + 1;
                else f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            }
        }
        
        cout << f[n][m] << endl;
    }
    
    return 0;
}
