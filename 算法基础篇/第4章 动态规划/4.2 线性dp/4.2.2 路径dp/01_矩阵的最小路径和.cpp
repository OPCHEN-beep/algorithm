//DP11 矩阵的最小路径和
//题目
//题解(45)
//讨论(15)
//排行
//中等  通过率：54.28%  时间限制：1秒  空间限制：256M
//知识点
//动态规划
//warning 校招时部分企业笔试将禁止编程题跳出页面，为提前适应，练习时请使用在线自测，而非本地IDE。
//描述
//给定一个 n * m 的矩阵 a，从左上角开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，输出所有的路径中最小的路径和。
//
//数据范围: 
//1
//≤
//n
//,
//m
//≤
//500
//1≤n,m≤500，矩阵中任意值都满足 
//0
//≤
//a
//i
//,
//j
//≤
//100
//0≤a 
//i,j
//?
// ≤100
//要求：时间复杂度 
//O
//(
//n
//m
//)
//O(nm)
//
//例如：当输入[[1,3,5,9],[8,1,3,4],[5,0,6,1],[8,8,4,0]]时，对应的返回值为12，
//所选择的最小累加和路径如下图所示：
//
//输入描述：
//第一行输入两个正整数 n 和 m 表示矩阵 a 的长宽
//后续输入 n 行每行有 m 个数表示矩阵的每个元素
//输出描述：
//输出从左上角到右下角的最小路径和
//示例1
//输入：
//4 4
//1 3 5 9
//8 1 3 4
//5 0 6 1
//8 8 4 0
//复制
//输出：
//12
//复制
//示例2
//输入：
//2 3
//1 2 3
//1 2 3
//复制
//输出：
//7
//复制

#include <iostream>
#include <cstring>
using namespace std;

const int N = 510;

int n, m;
int f[N][N];

int main()
{
    cin >> n >> m;

    //初始化
    memset(f, 0x3f, sizeof f);
    f[0][1] = 0;

    for(int i = 1; i <= n; i++)
    {
        for(int j = 1; j <= m; j++)
        {
            int x;
            cin >> x;
            f[i][j] = min(f[i - 1][j], f[i][j - 1]) + x;
        }
    }

    cout << f[n][m] << endl;

    return 0;
}
